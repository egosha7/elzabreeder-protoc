// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v5.27.3
// source: api/api.proto

package apiv1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	UserService_SaveUser_FullMethodName       = "/api.UserService/SaveUser"
	UserService_GetByUsername_FullMethodName  = "/api.UserService/GetByUsername"
	UserService_CheckUniqUser_FullMethodName  = "/api.UserService/CheckUniqUser"
	UserService_CheckValidUser_FullMethodName = "/api.UserService/CheckValidUser"
)

// UserServiceClient is the client API for UserService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Сервис для работы с пользователями
type UserServiceClient interface {
	SaveUser(ctx context.Context, in *SaveUserRequest, opts ...grpc.CallOption) (*SaveUserResponse, error)
	GetByUsername(ctx context.Context, in *GetByUsernameRequest, opts ...grpc.CallOption) (*GetByUsernameResponse, error)
	CheckUniqUser(ctx context.Context, in *CheckUniqUserRequest, opts ...grpc.CallOption) (*CheckUniqUserResponse, error)
	CheckValidUser(ctx context.Context, in *CheckValidUserRequest, opts ...grpc.CallOption) (*CheckValidUserResponse, error)
}

type userServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewUserServiceClient(cc grpc.ClientConnInterface) UserServiceClient {
	return &userServiceClient{cc}
}

func (c *userServiceClient) SaveUser(ctx context.Context, in *SaveUserRequest, opts ...grpc.CallOption) (*SaveUserResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SaveUserResponse)
	err := c.cc.Invoke(ctx, UserService_SaveUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) GetByUsername(ctx context.Context, in *GetByUsernameRequest, opts ...grpc.CallOption) (*GetByUsernameResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetByUsernameResponse)
	err := c.cc.Invoke(ctx, UserService_GetByUsername_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) CheckUniqUser(ctx context.Context, in *CheckUniqUserRequest, opts ...grpc.CallOption) (*CheckUniqUserResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CheckUniqUserResponse)
	err := c.cc.Invoke(ctx, UserService_CheckUniqUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) CheckValidUser(ctx context.Context, in *CheckValidUserRequest, opts ...grpc.CallOption) (*CheckValidUserResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CheckValidUserResponse)
	err := c.cc.Invoke(ctx, UserService_CheckValidUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserServiceServer is the server API for UserService service.
// All implementations must embed UnimplementedUserServiceServer
// for forward compatibility.
//
// Сервис для работы с пользователями
type UserServiceServer interface {
	SaveUser(context.Context, *SaveUserRequest) (*SaveUserResponse, error)
	GetByUsername(context.Context, *GetByUsernameRequest) (*GetByUsernameResponse, error)
	CheckUniqUser(context.Context, *CheckUniqUserRequest) (*CheckUniqUserResponse, error)
	CheckValidUser(context.Context, *CheckValidUserRequest) (*CheckValidUserResponse, error)
	mustEmbedUnimplementedUserServiceServer()
}

// UnimplementedUserServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedUserServiceServer struct{}

func (UnimplementedUserServiceServer) SaveUser(context.Context, *SaveUserRequest) (*SaveUserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SaveUser not implemented")
}
func (UnimplementedUserServiceServer) GetByUsername(context.Context, *GetByUsernameRequest) (*GetByUsernameResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetByUsername not implemented")
}
func (UnimplementedUserServiceServer) CheckUniqUser(context.Context, *CheckUniqUserRequest) (*CheckUniqUserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CheckUniqUser not implemented")
}
func (UnimplementedUserServiceServer) CheckValidUser(context.Context, *CheckValidUserRequest) (*CheckValidUserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CheckValidUser not implemented")
}
func (UnimplementedUserServiceServer) mustEmbedUnimplementedUserServiceServer() {}
func (UnimplementedUserServiceServer) testEmbeddedByValue()                     {}

// UnsafeUserServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserServiceServer will
// result in compilation errors.
type UnsafeUserServiceServer interface {
	mustEmbedUnimplementedUserServiceServer()
}

func RegisterUserServiceServer(s grpc.ServiceRegistrar, srv UserServiceServer) {
	// If the following call pancis, it indicates UnimplementedUserServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&UserService_ServiceDesc, srv)
}

func _UserService_SaveUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SaveUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).SaveUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_SaveUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).SaveUser(ctx, req.(*SaveUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_GetByUsername_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetByUsernameRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).GetByUsername(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_GetByUsername_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).GetByUsername(ctx, req.(*GetByUsernameRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_CheckUniqUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckUniqUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).CheckUniqUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_CheckUniqUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).CheckUniqUser(ctx, req.(*CheckUniqUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_CheckValidUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckValidUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).CheckValidUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_CheckValidUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).CheckValidUser(ctx, req.(*CheckValidUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// UserService_ServiceDesc is the grpc.ServiceDesc for UserService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "api.UserService",
	HandlerType: (*UserServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SaveUser",
			Handler:    _UserService_SaveUser_Handler,
		},
		{
			MethodName: "GetByUsername",
			Handler:    _UserService_GetByUsername_Handler,
		},
		{
			MethodName: "CheckUniqUser",
			Handler:    _UserService_CheckUniqUser_Handler,
		},
		{
			MethodName: "CheckValidUser",
			Handler:    _UserService_CheckValidUser_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/api.proto",
}

const (
	EmailService_AddEmail_FullMethodName = "/api.EmailService/AddEmail"
)

// EmailServiceClient is the client API for EmailService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Сервис для работы с email
type EmailServiceClient interface {
	AddEmail(ctx context.Context, in *AddEmailRequest, opts ...grpc.CallOption) (*AddEmailResponse, error)
}

type emailServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewEmailServiceClient(cc grpc.ClientConnInterface) EmailServiceClient {
	return &emailServiceClient{cc}
}

func (c *emailServiceClient) AddEmail(ctx context.Context, in *AddEmailRequest, opts ...grpc.CallOption) (*AddEmailResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AddEmailResponse)
	err := c.cc.Invoke(ctx, EmailService_AddEmail_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// EmailServiceServer is the server API for EmailService service.
// All implementations must embed UnimplementedEmailServiceServer
// for forward compatibility.
//
// Сервис для работы с email
type EmailServiceServer interface {
	AddEmail(context.Context, *AddEmailRequest) (*AddEmailResponse, error)
	mustEmbedUnimplementedEmailServiceServer()
}

// UnimplementedEmailServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedEmailServiceServer struct{}

func (UnimplementedEmailServiceServer) AddEmail(context.Context, *AddEmailRequest) (*AddEmailResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddEmail not implemented")
}
func (UnimplementedEmailServiceServer) mustEmbedUnimplementedEmailServiceServer() {}
func (UnimplementedEmailServiceServer) testEmbeddedByValue()                      {}

// UnsafeEmailServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to EmailServiceServer will
// result in compilation errors.
type UnsafeEmailServiceServer interface {
	mustEmbedUnimplementedEmailServiceServer()
}

func RegisterEmailServiceServer(s grpc.ServiceRegistrar, srv EmailServiceServer) {
	// If the following call pancis, it indicates UnimplementedEmailServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&EmailService_ServiceDesc, srv)
}

func _EmailService_AddEmail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddEmailRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmailServiceServer).AddEmail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EmailService_AddEmail_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmailServiceServer).AddEmail(ctx, req.(*AddEmailRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// EmailService_ServiceDesc is the grpc.ServiceDesc for EmailService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var EmailService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "api.EmailService",
	HandlerType: (*EmailServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddEmail",
			Handler:    _EmailService_AddEmail_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/api.proto",
}

const (
	PuppyService_PuppiesGet_FullMethodName          = "/api.PuppyService/PuppiesGet"
	PuppyService_PuppyGet_FullMethodName            = "/api.PuppyService/PuppyGet"
	PuppyService_PuppyUpdate_FullMethodName         = "/api.PuppyService/PuppyUpdate"
	PuppyService_PuppyAdd_FullMethodName            = "/api.PuppyService/PuppyAdd"
	PuppyService_PuppyDelete_FullMethodName         = "/api.PuppyService/PuppyDelete"
	PuppyService_PuppyChangeArchived_FullMethodName = "/api.PuppyService/PuppyChangeArchived"
)

// PuppyServiceClient is the client API for PuppyService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Сервис для работы с щенками
type PuppyServiceClient interface {
	PuppiesGet(ctx context.Context, in *PuppiesGetRequest, opts ...grpc.CallOption) (*PuppiesGetResponse, error)
	PuppyGet(ctx context.Context, in *PuppyRequest, opts ...grpc.CallOption) (*PuppyResponse, error)
	PuppyUpdate(ctx context.Context, in *PuppyUpdateRequest, opts ...grpc.CallOption) (*PuppyUpdateResponse, error)
	PuppyAdd(ctx context.Context, in *PuppyAddRequest, opts ...grpc.CallOption) (*PuppyAddResponse, error)
	PuppyDelete(ctx context.Context, in *PuppyDeleteRequest, opts ...grpc.CallOption) (*PuppyDeleteResponse, error)
	PuppyChangeArchived(ctx context.Context, in *PuppyChangeArchivedRequest, opts ...grpc.CallOption) (*PuppyChangeArchivedResponse, error)
}

type puppyServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewPuppyServiceClient(cc grpc.ClientConnInterface) PuppyServiceClient {
	return &puppyServiceClient{cc}
}

func (c *puppyServiceClient) PuppiesGet(ctx context.Context, in *PuppiesGetRequest, opts ...grpc.CallOption) (*PuppiesGetResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PuppiesGetResponse)
	err := c.cc.Invoke(ctx, PuppyService_PuppiesGet_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *puppyServiceClient) PuppyGet(ctx context.Context, in *PuppyRequest, opts ...grpc.CallOption) (*PuppyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PuppyResponse)
	err := c.cc.Invoke(ctx, PuppyService_PuppyGet_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *puppyServiceClient) PuppyUpdate(ctx context.Context, in *PuppyUpdateRequest, opts ...grpc.CallOption) (*PuppyUpdateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PuppyUpdateResponse)
	err := c.cc.Invoke(ctx, PuppyService_PuppyUpdate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *puppyServiceClient) PuppyAdd(ctx context.Context, in *PuppyAddRequest, opts ...grpc.CallOption) (*PuppyAddResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PuppyAddResponse)
	err := c.cc.Invoke(ctx, PuppyService_PuppyAdd_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *puppyServiceClient) PuppyDelete(ctx context.Context, in *PuppyDeleteRequest, opts ...grpc.CallOption) (*PuppyDeleteResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PuppyDeleteResponse)
	err := c.cc.Invoke(ctx, PuppyService_PuppyDelete_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *puppyServiceClient) PuppyChangeArchived(ctx context.Context, in *PuppyChangeArchivedRequest, opts ...grpc.CallOption) (*PuppyChangeArchivedResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PuppyChangeArchivedResponse)
	err := c.cc.Invoke(ctx, PuppyService_PuppyChangeArchived_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PuppyServiceServer is the server API for PuppyService service.
// All implementations must embed UnimplementedPuppyServiceServer
// for forward compatibility.
//
// Сервис для работы с щенками
type PuppyServiceServer interface {
	PuppiesGet(context.Context, *PuppiesGetRequest) (*PuppiesGetResponse, error)
	PuppyGet(context.Context, *PuppyRequest) (*PuppyResponse, error)
	PuppyUpdate(context.Context, *PuppyUpdateRequest) (*PuppyUpdateResponse, error)
	PuppyAdd(context.Context, *PuppyAddRequest) (*PuppyAddResponse, error)
	PuppyDelete(context.Context, *PuppyDeleteRequest) (*PuppyDeleteResponse, error)
	PuppyChangeArchived(context.Context, *PuppyChangeArchivedRequest) (*PuppyChangeArchivedResponse, error)
	mustEmbedUnimplementedPuppyServiceServer()
}

// UnimplementedPuppyServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedPuppyServiceServer struct{}

func (UnimplementedPuppyServiceServer) PuppiesGet(context.Context, *PuppiesGetRequest) (*PuppiesGetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PuppiesGet not implemented")
}
func (UnimplementedPuppyServiceServer) PuppyGet(context.Context, *PuppyRequest) (*PuppyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PuppyGet not implemented")
}
func (UnimplementedPuppyServiceServer) PuppyUpdate(context.Context, *PuppyUpdateRequest) (*PuppyUpdateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PuppyUpdate not implemented")
}
func (UnimplementedPuppyServiceServer) PuppyAdd(context.Context, *PuppyAddRequest) (*PuppyAddResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PuppyAdd not implemented")
}
func (UnimplementedPuppyServiceServer) PuppyDelete(context.Context, *PuppyDeleteRequest) (*PuppyDeleteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PuppyDelete not implemented")
}
func (UnimplementedPuppyServiceServer) PuppyChangeArchived(context.Context, *PuppyChangeArchivedRequest) (*PuppyChangeArchivedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PuppyChangeArchived not implemented")
}
func (UnimplementedPuppyServiceServer) mustEmbedUnimplementedPuppyServiceServer() {}
func (UnimplementedPuppyServiceServer) testEmbeddedByValue()                      {}

// UnsafePuppyServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PuppyServiceServer will
// result in compilation errors.
type UnsafePuppyServiceServer interface {
	mustEmbedUnimplementedPuppyServiceServer()
}

func RegisterPuppyServiceServer(s grpc.ServiceRegistrar, srv PuppyServiceServer) {
	// If the following call pancis, it indicates UnimplementedPuppyServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&PuppyService_ServiceDesc, srv)
}

func _PuppyService_PuppiesGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PuppiesGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PuppyServiceServer).PuppiesGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PuppyService_PuppiesGet_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PuppyServiceServer).PuppiesGet(ctx, req.(*PuppiesGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PuppyService_PuppyGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PuppyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PuppyServiceServer).PuppyGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PuppyService_PuppyGet_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PuppyServiceServer).PuppyGet(ctx, req.(*PuppyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PuppyService_PuppyUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PuppyUpdateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PuppyServiceServer).PuppyUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PuppyService_PuppyUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PuppyServiceServer).PuppyUpdate(ctx, req.(*PuppyUpdateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PuppyService_PuppyAdd_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PuppyAddRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PuppyServiceServer).PuppyAdd(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PuppyService_PuppyAdd_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PuppyServiceServer).PuppyAdd(ctx, req.(*PuppyAddRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PuppyService_PuppyDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PuppyDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PuppyServiceServer).PuppyDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PuppyService_PuppyDelete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PuppyServiceServer).PuppyDelete(ctx, req.(*PuppyDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PuppyService_PuppyChangeArchived_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PuppyChangeArchivedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PuppyServiceServer).PuppyChangeArchived(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PuppyService_PuppyChangeArchived_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PuppyServiceServer).PuppyChangeArchived(ctx, req.(*PuppyChangeArchivedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// PuppyService_ServiceDesc is the grpc.ServiceDesc for PuppyService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PuppyService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "api.PuppyService",
	HandlerType: (*PuppyServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "PuppiesGet",
			Handler:    _PuppyService_PuppiesGet_Handler,
		},
		{
			MethodName: "PuppyGet",
			Handler:    _PuppyService_PuppyGet_Handler,
		},
		{
			MethodName: "PuppyUpdate",
			Handler:    _PuppyService_PuppyUpdate_Handler,
		},
		{
			MethodName: "PuppyAdd",
			Handler:    _PuppyService_PuppyAdd_Handler,
		},
		{
			MethodName: "PuppyDelete",
			Handler:    _PuppyService_PuppyDelete_Handler,
		},
		{
			MethodName: "PuppyChangeArchived",
			Handler:    _PuppyService_PuppyChangeArchived_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/api.proto",
}

const (
	DogService_DogGet_FullMethodName            = "/api.DogService/DogGet"
	DogService_DogsGet_FullMethodName           = "/api.DogService/DogsGet"
	DogService_DogChangeArchived_FullMethodName = "/api.DogService/DogChangeArchived"
	DogService_DogAdd_FullMethodName            = "/api.DogService/DogAdd"
	DogService_DogUpdate_FullMethodName         = "/api.DogService/DogUpdate"
)

// DogServiceClient is the client API for DogService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Сервис для работы с собаками
type DogServiceClient interface {
	DogGet(ctx context.Context, in *DogRequest, opts ...grpc.CallOption) (*DogResponse, error)
	DogsGet(ctx context.Context, in *DogsGetRequest, opts ...grpc.CallOption) (*DogsGetResponse, error)
	DogChangeArchived(ctx context.Context, in *DogChangeArchivedRequest, opts ...grpc.CallOption) (*DogChangeArchivedResponse, error)
	DogAdd(ctx context.Context, in *DogAddRequest, opts ...grpc.CallOption) (*DogAddResponse, error)
	DogUpdate(ctx context.Context, in *DogUpdateRequest, opts ...grpc.CallOption) (*DogUpdateResponse, error)
}

type dogServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewDogServiceClient(cc grpc.ClientConnInterface) DogServiceClient {
	return &dogServiceClient{cc}
}

func (c *dogServiceClient) DogGet(ctx context.Context, in *DogRequest, opts ...grpc.CallOption) (*DogResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DogResponse)
	err := c.cc.Invoke(ctx, DogService_DogGet_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dogServiceClient) DogsGet(ctx context.Context, in *DogsGetRequest, opts ...grpc.CallOption) (*DogsGetResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DogsGetResponse)
	err := c.cc.Invoke(ctx, DogService_DogsGet_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dogServiceClient) DogChangeArchived(ctx context.Context, in *DogChangeArchivedRequest, opts ...grpc.CallOption) (*DogChangeArchivedResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DogChangeArchivedResponse)
	err := c.cc.Invoke(ctx, DogService_DogChangeArchived_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dogServiceClient) DogAdd(ctx context.Context, in *DogAddRequest, opts ...grpc.CallOption) (*DogAddResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DogAddResponse)
	err := c.cc.Invoke(ctx, DogService_DogAdd_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dogServiceClient) DogUpdate(ctx context.Context, in *DogUpdateRequest, opts ...grpc.CallOption) (*DogUpdateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DogUpdateResponse)
	err := c.cc.Invoke(ctx, DogService_DogUpdate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DogServiceServer is the server API for DogService service.
// All implementations must embed UnimplementedDogServiceServer
// for forward compatibility.
//
// Сервис для работы с собаками
type DogServiceServer interface {
	DogGet(context.Context, *DogRequest) (*DogResponse, error)
	DogsGet(context.Context, *DogsGetRequest) (*DogsGetResponse, error)
	DogChangeArchived(context.Context, *DogChangeArchivedRequest) (*DogChangeArchivedResponse, error)
	DogAdd(context.Context, *DogAddRequest) (*DogAddResponse, error)
	DogUpdate(context.Context, *DogUpdateRequest) (*DogUpdateResponse, error)
	mustEmbedUnimplementedDogServiceServer()
}

// UnimplementedDogServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedDogServiceServer struct{}

func (UnimplementedDogServiceServer) DogGet(context.Context, *DogRequest) (*DogResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DogGet not implemented")
}
func (UnimplementedDogServiceServer) DogsGet(context.Context, *DogsGetRequest) (*DogsGetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DogsGet not implemented")
}
func (UnimplementedDogServiceServer) DogChangeArchived(context.Context, *DogChangeArchivedRequest) (*DogChangeArchivedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DogChangeArchived not implemented")
}
func (UnimplementedDogServiceServer) DogAdd(context.Context, *DogAddRequest) (*DogAddResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DogAdd not implemented")
}
func (UnimplementedDogServiceServer) DogUpdate(context.Context, *DogUpdateRequest) (*DogUpdateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DogUpdate not implemented")
}
func (UnimplementedDogServiceServer) mustEmbedUnimplementedDogServiceServer() {}
func (UnimplementedDogServiceServer) testEmbeddedByValue()                    {}

// UnsafeDogServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DogServiceServer will
// result in compilation errors.
type UnsafeDogServiceServer interface {
	mustEmbedUnimplementedDogServiceServer()
}

func RegisterDogServiceServer(s grpc.ServiceRegistrar, srv DogServiceServer) {
	// If the following call pancis, it indicates UnimplementedDogServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&DogService_ServiceDesc, srv)
}

func _DogService_DogGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DogRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DogServiceServer).DogGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DogService_DogGet_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DogServiceServer).DogGet(ctx, req.(*DogRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DogService_DogsGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DogsGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DogServiceServer).DogsGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DogService_DogsGet_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DogServiceServer).DogsGet(ctx, req.(*DogsGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DogService_DogChangeArchived_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DogChangeArchivedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DogServiceServer).DogChangeArchived(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DogService_DogChangeArchived_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DogServiceServer).DogChangeArchived(ctx, req.(*DogChangeArchivedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DogService_DogAdd_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DogAddRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DogServiceServer).DogAdd(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DogService_DogAdd_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DogServiceServer).DogAdd(ctx, req.(*DogAddRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DogService_DogUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DogUpdateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DogServiceServer).DogUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DogService_DogUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DogServiceServer).DogUpdate(ctx, req.(*DogUpdateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// DogService_ServiceDesc is the grpc.ServiceDesc for DogService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var DogService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "api.DogService",
	HandlerType: (*DogServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "DogGet",
			Handler:    _DogService_DogGet_Handler,
		},
		{
			MethodName: "DogsGet",
			Handler:    _DogService_DogsGet_Handler,
		},
		{
			MethodName: "DogChangeArchived",
			Handler:    _DogService_DogChangeArchived_Handler,
		},
		{
			MethodName: "DogAdd",
			Handler:    _DogService_DogAdd_Handler,
		},
		{
			MethodName: "DogUpdate",
			Handler:    _DogService_DogUpdate_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/api.proto",
}

const (
	FeedbackService_PuppiesWithReviewsGet_FullMethodName = "/api.FeedbackService/PuppiesWithReviewsGet"
	FeedbackService_ReviewsGet_FullMethodName            = "/api.FeedbackService/ReviewsGet"
	FeedbackService_GetReviews_FullMethodName            = "/api.FeedbackService/GetReviews"
	FeedbackService_FeedbackGet_FullMethodName           = "/api.FeedbackService/FeedbackGet"
	FeedbackService_FeedbackAdd_FullMethodName           = "/api.FeedbackService/FeedbackAdd"
	FeedbackService_FeedbackUpdate_FullMethodName        = "/api.FeedbackService/FeedbackUpdate"
	FeedbackService_FeedbackDelete_FullMethodName        = "/api.FeedbackService/FeedbackDelete"
	FeedbackService_FeedbackChangeChecked_FullMethodName = "/api.FeedbackService/FeedbackChangeChecked"
)

// FeedbackServiceClient is the client API for FeedbackService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Сервис для работы с отзывами
type FeedbackServiceClient interface {
	PuppiesWithReviewsGet(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*PuppiesWithReviewsGetResponse, error)
	ReviewsGet(ctx context.Context, in *ReviewsGetRequest, opts ...grpc.CallOption) (*ReviewsGetResponse, error)
	GetReviews(ctx context.Context, in *GetReviewsRequest, opts ...grpc.CallOption) (*GetReviewsResponse, error)
	FeedbackGet(ctx context.Context, in *FeedbackRequest, opts ...grpc.CallOption) (*FeedbackResponse, error)
	FeedbackAdd(ctx context.Context, in *FeedbackAddRequest, opts ...grpc.CallOption) (*FeedbackAddResponse, error)
	FeedbackUpdate(ctx context.Context, in *FeedbackUpdateRequest, opts ...grpc.CallOption) (*FeedbackUpdateResponse, error)
	FeedbackDelete(ctx context.Context, in *FeedbackDeleteRequest, opts ...grpc.CallOption) (*FeedbackDeleteResponse, error)
	FeedbackChangeChecked(ctx context.Context, in *FeedbackChangeCheckedRequest, opts ...grpc.CallOption) (*FeedbackChangeCheckedResponse, error)
}

type feedbackServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewFeedbackServiceClient(cc grpc.ClientConnInterface) FeedbackServiceClient {
	return &feedbackServiceClient{cc}
}

func (c *feedbackServiceClient) PuppiesWithReviewsGet(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*PuppiesWithReviewsGetResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PuppiesWithReviewsGetResponse)
	err := c.cc.Invoke(ctx, FeedbackService_PuppiesWithReviewsGet_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *feedbackServiceClient) ReviewsGet(ctx context.Context, in *ReviewsGetRequest, opts ...grpc.CallOption) (*ReviewsGetResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReviewsGetResponse)
	err := c.cc.Invoke(ctx, FeedbackService_ReviewsGet_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *feedbackServiceClient) GetReviews(ctx context.Context, in *GetReviewsRequest, opts ...grpc.CallOption) (*GetReviewsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetReviewsResponse)
	err := c.cc.Invoke(ctx, FeedbackService_GetReviews_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *feedbackServiceClient) FeedbackGet(ctx context.Context, in *FeedbackRequest, opts ...grpc.CallOption) (*FeedbackResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FeedbackResponse)
	err := c.cc.Invoke(ctx, FeedbackService_FeedbackGet_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *feedbackServiceClient) FeedbackAdd(ctx context.Context, in *FeedbackAddRequest, opts ...grpc.CallOption) (*FeedbackAddResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FeedbackAddResponse)
	err := c.cc.Invoke(ctx, FeedbackService_FeedbackAdd_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *feedbackServiceClient) FeedbackUpdate(ctx context.Context, in *FeedbackUpdateRequest, opts ...grpc.CallOption) (*FeedbackUpdateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FeedbackUpdateResponse)
	err := c.cc.Invoke(ctx, FeedbackService_FeedbackUpdate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *feedbackServiceClient) FeedbackDelete(ctx context.Context, in *FeedbackDeleteRequest, opts ...grpc.CallOption) (*FeedbackDeleteResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FeedbackDeleteResponse)
	err := c.cc.Invoke(ctx, FeedbackService_FeedbackDelete_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *feedbackServiceClient) FeedbackChangeChecked(ctx context.Context, in *FeedbackChangeCheckedRequest, opts ...grpc.CallOption) (*FeedbackChangeCheckedResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FeedbackChangeCheckedResponse)
	err := c.cc.Invoke(ctx, FeedbackService_FeedbackChangeChecked_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// FeedbackServiceServer is the server API for FeedbackService service.
// All implementations must embed UnimplementedFeedbackServiceServer
// for forward compatibility.
//
// Сервис для работы с отзывами
type FeedbackServiceServer interface {
	PuppiesWithReviewsGet(context.Context, *emptypb.Empty) (*PuppiesWithReviewsGetResponse, error)
	ReviewsGet(context.Context, *ReviewsGetRequest) (*ReviewsGetResponse, error)
	GetReviews(context.Context, *GetReviewsRequest) (*GetReviewsResponse, error)
	FeedbackGet(context.Context, *FeedbackRequest) (*FeedbackResponse, error)
	FeedbackAdd(context.Context, *FeedbackAddRequest) (*FeedbackAddResponse, error)
	FeedbackUpdate(context.Context, *FeedbackUpdateRequest) (*FeedbackUpdateResponse, error)
	FeedbackDelete(context.Context, *FeedbackDeleteRequest) (*FeedbackDeleteResponse, error)
	FeedbackChangeChecked(context.Context, *FeedbackChangeCheckedRequest) (*FeedbackChangeCheckedResponse, error)
	mustEmbedUnimplementedFeedbackServiceServer()
}

// UnimplementedFeedbackServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedFeedbackServiceServer struct{}

func (UnimplementedFeedbackServiceServer) PuppiesWithReviewsGet(context.Context, *emptypb.Empty) (*PuppiesWithReviewsGetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PuppiesWithReviewsGet not implemented")
}
func (UnimplementedFeedbackServiceServer) ReviewsGet(context.Context, *ReviewsGetRequest) (*ReviewsGetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReviewsGet not implemented")
}
func (UnimplementedFeedbackServiceServer) GetReviews(context.Context, *GetReviewsRequest) (*GetReviewsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetReviews not implemented")
}
func (UnimplementedFeedbackServiceServer) FeedbackGet(context.Context, *FeedbackRequest) (*FeedbackResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FeedbackGet not implemented")
}
func (UnimplementedFeedbackServiceServer) FeedbackAdd(context.Context, *FeedbackAddRequest) (*FeedbackAddResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FeedbackAdd not implemented")
}
func (UnimplementedFeedbackServiceServer) FeedbackUpdate(context.Context, *FeedbackUpdateRequest) (*FeedbackUpdateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FeedbackUpdate not implemented")
}
func (UnimplementedFeedbackServiceServer) FeedbackDelete(context.Context, *FeedbackDeleteRequest) (*FeedbackDeleteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FeedbackDelete not implemented")
}
func (UnimplementedFeedbackServiceServer) FeedbackChangeChecked(context.Context, *FeedbackChangeCheckedRequest) (*FeedbackChangeCheckedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FeedbackChangeChecked not implemented")
}
func (UnimplementedFeedbackServiceServer) mustEmbedUnimplementedFeedbackServiceServer() {}
func (UnimplementedFeedbackServiceServer) testEmbeddedByValue()                         {}

// UnsafeFeedbackServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to FeedbackServiceServer will
// result in compilation errors.
type UnsafeFeedbackServiceServer interface {
	mustEmbedUnimplementedFeedbackServiceServer()
}

func RegisterFeedbackServiceServer(s grpc.ServiceRegistrar, srv FeedbackServiceServer) {
	// If the following call pancis, it indicates UnimplementedFeedbackServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&FeedbackService_ServiceDesc, srv)
}

func _FeedbackService_PuppiesWithReviewsGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FeedbackServiceServer).PuppiesWithReviewsGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FeedbackService_PuppiesWithReviewsGet_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FeedbackServiceServer).PuppiesWithReviewsGet(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _FeedbackService_ReviewsGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReviewsGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FeedbackServiceServer).ReviewsGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FeedbackService_ReviewsGet_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FeedbackServiceServer).ReviewsGet(ctx, req.(*ReviewsGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FeedbackService_GetReviews_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetReviewsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FeedbackServiceServer).GetReviews(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FeedbackService_GetReviews_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FeedbackServiceServer).GetReviews(ctx, req.(*GetReviewsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FeedbackService_FeedbackGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FeedbackRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FeedbackServiceServer).FeedbackGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FeedbackService_FeedbackGet_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FeedbackServiceServer).FeedbackGet(ctx, req.(*FeedbackRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FeedbackService_FeedbackAdd_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FeedbackAddRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FeedbackServiceServer).FeedbackAdd(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FeedbackService_FeedbackAdd_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FeedbackServiceServer).FeedbackAdd(ctx, req.(*FeedbackAddRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FeedbackService_FeedbackUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FeedbackUpdateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FeedbackServiceServer).FeedbackUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FeedbackService_FeedbackUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FeedbackServiceServer).FeedbackUpdate(ctx, req.(*FeedbackUpdateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FeedbackService_FeedbackDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FeedbackDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FeedbackServiceServer).FeedbackDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FeedbackService_FeedbackDelete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FeedbackServiceServer).FeedbackDelete(ctx, req.(*FeedbackDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FeedbackService_FeedbackChangeChecked_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FeedbackChangeCheckedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FeedbackServiceServer).FeedbackChangeChecked(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FeedbackService_FeedbackChangeChecked_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FeedbackServiceServer).FeedbackChangeChecked(ctx, req.(*FeedbackChangeCheckedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// FeedbackService_ServiceDesc is the grpc.ServiceDesc for FeedbackService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var FeedbackService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "api.FeedbackService",
	HandlerType: (*FeedbackServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "PuppiesWithReviewsGet",
			Handler:    _FeedbackService_PuppiesWithReviewsGet_Handler,
		},
		{
			MethodName: "ReviewsGet",
			Handler:    _FeedbackService_ReviewsGet_Handler,
		},
		{
			MethodName: "GetReviews",
			Handler:    _FeedbackService_GetReviews_Handler,
		},
		{
			MethodName: "FeedbackGet",
			Handler:    _FeedbackService_FeedbackGet_Handler,
		},
		{
			MethodName: "FeedbackAdd",
			Handler:    _FeedbackService_FeedbackAdd_Handler,
		},
		{
			MethodName: "FeedbackUpdate",
			Handler:    _FeedbackService_FeedbackUpdate_Handler,
		},
		{
			MethodName: "FeedbackDelete",
			Handler:    _FeedbackService_FeedbackDelete_Handler,
		},
		{
			MethodName: "FeedbackChangeChecked",
			Handler:    _FeedbackService_FeedbackChangeChecked_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/api.proto",
}
